%section#intro
  %h1 Qush
  %p A UNIX Shell Suitable For Large Programs
  .tagline
    %p Jeanine Adkisson
    %p Programming Research Group, Tokyo Institute of Technology
    %p
      %code
        advisor: Hidehiko Masuhara
    %p
      %code
        slides:
        %a(href="https://jneen.github.io/prg-qush-slides") https://jneen.github.io/prg-qush-slides
    %p
      %code
        mailto:
        %a(href="mailto:jneen@prg.is.titech.ac.jp") jneen@prg.is.titech.ac.jp


%section<
  %h2 Shells Are Bad.
  %h2 But Everyone Uses Them.
  .vs>
    = code 'shell' do
      :plain
        #!/bin/bash

        getc() {
          IFS= read -r -n1 -d '' "$@"
        }
  .vs>
    = code 'shell' do
      :plain
        #!/bin/bash

        greeting='hello world'
        count-argv $greeting # => 2
        count-argv 'hello world' # => 1


%section
  %h2 Why?
  .vs>
    .box
      %h3 Ubiquity:
      .block
        Available on any UNIX platform!
  .vs>
    .box
      %h3 OS Fluency:
      .block
        &ldquo;Feels&rdquo; close to the OS

%section(data-transition="slide-in fade-out")
  %h2
    What Makes a Shell Feel <span class="dune">&ldquo;Fluent&rdquo;</span>?
  .bigger
    %strong.sandy Core language concepts directly map to OS APIs
  .block
    .vs3>
      .box environments
    .vs3>
      .box argv
    .vs3>
      .box processes
    .vs3>
      .box pipes, files, stdio
    .vs3>
      .box commands
    .vs3>
      .box return codes

  concepts every <span class="dune">&ldquo;general-purpose&rdquo;</span> programming language understands.


%section(data-transition="fade-in slide-out")
  %h2 Main Idea
  %h3 A language that expands UNIX concepts to language abstractions

  .block
    .vs3>
      .box environments:<br>prototype objects!
    .vs3>
      .box argv:<br>vectors (nestable!)
    .vs3>
      .box processes:<br>threads!
    .vs3>
      .box pipes, files, stdio:<br>channels!
    .vs3>
      .box commands:<br>functions (w/closure!)
    .vs3>
      .box return codes:<br>error handling!

%section
  %h2 Design Philosophy

  %ul
    %li
      Derive all language concepts from UNIX APIs<br>
      (as opposed to embedding another language's semantics,<br>
      like <code>xonsh</code> or <code>scheme-shell</code>)
    %li Minimal marshalling, no quotes for <code>exec</code>
    %li
      Provide real value-based semantics and abstraction tools<br>
      (as opposed to everything-is-a-string, like <code>es</code> or <code>fish</code>)


%section
  %h2 Language Design


%section
  %h2 Language Design: Values
  %h3 Not everything is a string!

  %ul
    %li
      Variables can hold <strong>values</strong>: string, number,
      vector, environment, channel, process, function
    %li
      Channels can handle values, not just bytes
    %li
      Functions take values as arguments


%section
  %h2 Language Design: Call Semantics
  %h3 Multiple return values using stdout.

  .block
    .vs>
      = code 'qsh' do
        :plain
          (count-three ?n) = (
            put %n
            put (incr %n)
            put (incr (incr %n))
          )
    .vs>
      = code 'console?lang=qsh' do
        :plain
          ; put 0 (count-three 1) 4

          => 0; => 1; => 2; => 3; => 4

  Equivalent to shell <code>$(command arg arg)</code>


%section
  %h2 Language Design: Variable Scope

  .block
    .vs>
      %h3 Dynamic with <code>$</code>
      = code 'console?lang=qsh' do
        :plain
          ; x = 1
          ; (f) = (put $x)
          ; (g) = (x = 2; f)
          ; g
          2

    .vs>
      %h3 Lexical with <code>%</code>
      = code 'console?lang=qsh' do
        :plain
          ; x = 1
          ; (f) = (put %x)
          ; (g) = (x = 2; f)
          ; g
          1

  Dynamic variables = UNIX environment variables

%section
  %h2 Language Design: Variable Scope

  .block
    .vs>
      %h3 Dynamic with <code>$</code>
      = code 'console?lang=qsh' do
        :plain
          ; x = 1
          ; (f) = ($x = 3)
          ; (g) = (x = 2; f; put $x)
          ; g; put $x
          3 1

    .vs>
      %h3 Lexical with <code>%</code>
      = code 'console?lang=qsh' do
        :plain
          ; x = 1
          ; (f) = (%x = 3)
          ; (g) = (x = 2; f; put $x)
          ; g; put $x
          2 3

  Dynamic variables = UNIX environment variables

%section
  %h2 Language Design: Objects

  .block
    .vs>
      %h3 Instantiation
      = code 'qsh' do
        :plain
          my-env = {
            # regular members
            x = 1

            # functions
            (my-function ?arg) = ...

            # in scope within {}
            %self
          }

    .vs>
      %h3 Usage
      = code 'qsh' do
        :plain
          # regular members
          $my-env!x

          # functions
          $my-env!my-function 23

          +$my-env (
            my-function $x
          )



/%section
/  %h2 Language Design: Compatibility
/
/  .vs>
/    %ul
/      %li Idea: pass lambdas to external programs
/      %li <code>/usr/bin/qush-external-<emph>N</emph></code>
/      %li Standard <code>exec</code> interface
/      %li <code>$__QUSH_SERVER</code> and <code>$__QUSH_FUNCTION_<emph>N</emph></code>
/
/  .vs>
/    = code 'qsh' do
/      :plain
/
/        # calls into $my-fn in the
/        # current runtime once
/        # every 3 seconds
/
/        ; /usr/bin/watch -d 3 $my-fn
/
/  Bash cannot currently do this.


/%section
/  %h2 Language Design: Error Handling
/  %h3 Default Behavior
/
/  An &ldquo;error&rdquo; includes:
/
/  .block
/    %ul
/      %li Assertion error (type error or explicit crash)
/      %li External crash signal (SIGINT, etc)
/      %li A child process exits with nonzero code
/      %li A blocked channel closes


/%section
/  %h2 Language Design: Error Handling
/  %h3 Default Behavior
/  When an error happens:
/  .block
/    %ul
/      %li All child processes are sent SIGINT (or echo signal)
/      %li Compensations are run in reverse order (more later)
/      %li All channels are closed
/      %li Exit with an error code (default 1)

%section
  %h2 Language Design: Error Handling
  %h3 Plain Recovery (Continuing)

  .block
    = code 'qsh' do
      :plain
        command || command-if-error
        command && command-if-no-error
        command && command-if-no-error !! command-if-error

  .block Internal errors (non-zero exits) in the original command are &ldquo;rescued&rdquo; (ignored)

  .block <code class="scarletred2">TODO:</code> Syntax for targetting error types


%section
  %h2 Language Design: Error Handling
  %h3 Compensation

  = code 'qsh' do
    :plain
      touch /tmp/lock %% rm -f /tmp/lock # compensate an error

      %x = command %% reset # sets $COMP_REF and $COMP_PREV

      checkpoint # clears the current compensation stack

  .space
  = code 'qsh' do
    :plain
      touch /tmp/lock %%! rm -f /tmp/lock # run on error or at checkpoint
  %br

  .block <code class="scarletred2">TODO:</code> Compensation boundaries
  /Options being considered for compensation boundaries:
  /.block
  /  %ul
  /    %li Only at the procedure level
  /    %li Controlled by a special environment variable



/%section
/  %h2 Language Design: Concurrency
/  Many things TBD, but the principle is:
/  %h3 Behave as closely to UNIX processes as possible.
/  .vs>
/    = code 'qsh' do
/      :plain
/        # spawn
/        & command $arg $arg > $out < $in
/
/        # send
/        put message > $in
/
/        # receive
/        get message < $out
/    // vim syntax highlighting gets confused here
/    // >
/  .vs>
/    .block
/      %ul
/        %li local environment contains file handles 0~127
/        %li 0 = stdin, 1 = stdout, 2 = stderr, etc
/    = code 'qsh' do
/      :plain
/        command | command
/        command |[5>2] command
/        command |[2>$ERROR_LOG] command

%section
  %h2 Concurrency: Concepts

  .vs>
    %h4 Channels as values
    = code 'qsh' do
      :plain
        channel = (make-channel)
        reader < $channel
        writer > $channel

  .vs>
    %h4 Anonymous channels (pipes)
    = code 'qsh' do
      :plain
        command-1 | command-2

        # equivalent to

        channel = (make-channel)

        spawn [
          (=> command-1 > %channel)
          (=> command-2 < %channel) ]

-# vimmmm
-# >

%section
  %h2 Concurrency: Concepts

  %p
    Channels are <strong>synchronous</strong>:
  %ul
    %li reader and writer must both be present to make a communication.
    %li Writes will <strong>block</strong> until the channel is read.

  .vs>
    %h4 Block on read
    = code 'qsh' do
      :plain
        (sleep 10; put 1) | get


  .vs>
    %h4 Block on write
    = code 'qsh' do
      :plain
        put 1 | (sleep 10; get)

  %h4.fragment This is different than bash!

%section
  %h2 Concurrency: Interruption

  %h3 What should the behavior of this code be?

  .vs>
    = code 'qsh' do
      :plain
        (count-forever ?n) = (
          put %n
          count-forever (incr %n)
        )

        (take 0) = ()
        (take ?n) = (
          put (get)
          take (decr %n)
        )

        count-forever 0 | take 10

  .replacement.vs>
    .fragment.current-visible
      = code 'qsh' do
        :plain
          => 0; => 1; => 2; => ...; => 9

          # but what happens to the process
          # running `count-forever`...?

    .block.fragment
      %h4 Naive Approach: Nothing!

      %ul
        %li
          %span.code count-forever
          tries to write 10 to the output, blocks
        %li
          %span.code take
          returns after 9, never reads
        %li
          %span.code count-forever
          gets garbage-collected later

    .fragment.box
      %h4 This works!
      %p ...as long as there are no cleanup actions

%section(data-transition="slide-in fade-out")
  %h2 Concurrency: Interruption

  %h3 But what if there are cleanup actions?

  .vs>
    = code 'qsh' do
      :plain
        (file-lines ?fname) = (
          file = (open-file %fname
            %%! close-file %fname)
          ...
        )


        file-lines /tmp/huge-file
          | take 10

  .vs.nfragment>
    %h4
      With the naive approach, the file will remain open until gc!

    .space
    %p.left Processes expect to be cleaned up when the processes they're communicating with hang up.

    .space
    %p.left They expect an <strong>interrupt</strong> signal of some kind.

%section(data-transition="fade-in slide-out")
  %h2 Concurrency: Interruption

  %h3 Idea: channel-closing semantics

  .vs>
    = code 'qsh' do
      :plain
        (file-lines ?fname) = (
          file = (open-file %fname
            %%! close-file %fname)
          ...
        )


        file-lines /tmp/huge-file
          | take 10

  .vs>
    %ul
      %li.fragment
        When
        %span.code take 10
        returns, it
        %strong closes
        the channel.

      %li.fragment
        The
        %span.code file-lines
        process is either blocked on the channel or tries to write later

      %li.fragment
        Either situation results in the
        %span.code file-lines
        process being
        %strong< interrupted
        , and having its cleanup actions run.

      .space
      %h4.fragment This is how it works in bash already!

%section
  %h2 Concurrency: Interruption

  %h3 Problem: Closing Semantics = No Dynamic Channels

  %h4 We can no longer write to a channel and leave it open!

  .block
    = code 'qsh' do
      :plain
        (make-broadcaster) = (
          outputs = []

          put {
            (subscribe ?ch) = (%outputs = [...%outputs %ch])
            (publish ?msg) = (for %outputs | each (%ch => put %msg > %ch))
          }
        )

  %h4.fragment We can't keep a dynamic list of channels open continuously for writing.

%section
  %h2 Concurrency: Interruption

  %h3 Possible Solutions

  .block
    .vs>
      %h4 Add a non-closing <span class="code">&gt;&gt;</span> operator.

      = code 'qsh' do
        :plain
          (publish ?msg) = (
            for %outputs
            | each (?ch =>
              put %msg >> %ch)
          )

    .vs>
      %h4 Manually control the open/close state:

      = code 'qsh' do
        :plain
          (subscribe ?ch) = (
            %outputs = [...%outputs %ch]
            incr-writers %ch
          )

%section
  %h2 Concurrency: Interruption

  %h3 Possible Solutions

  .block
    .vs>
      %h4 Multiple writers to stdout (<span class="code">&amp;1</span>)
      = code 'qsh' do
        :plain
          (subscribe >?c) = (
            %channels = [...%channels %c]

            # never return!
            # keep stdout open!
            sleep-forever
          )

          # usage
          $bc!subscribe > $somewhere

    .vs.fragment>
      %h4 This is how UNIX FIFOs work!
      %h4 (except they have a fixed buffer)
      = code 'console' do
        :plain
          ~$ echo 'demo time!'
          demo time!
          ~$ 





%section
  %h2 Implementation Progress

%section
  %h2 Implementation Progress

  .block
    %ul
      %li RPython Implementation on hold for now
      %li Creating Ruby DSL (&ldquo;magritte&rdquo;) to test concurrency primitives
      %li
        Will likely attempt to publish a limited version of the language<br/>
        that only focuses on concurrency, and add shell compatibility in<br/>
        a separate paper.

/%section
/  %h2 Implementation Progress
/  %h3 RPython + MacroPy
/  .block
/    = code 'python' do
/      :plain
/        @functor
/        class Syntax:
/            class list([elements]): pass
/            class paren([statements]): pass
/            class assign(~lhs, ~rhs): pass
/            class bare(value/unicode): pass
/            class dynvar(name/unicode): pass
/            class pipe(~lhs, ~rhs): pass
/            class call(loc/LocRange, ~func, [args]): pass
/            ...
/
/%section
/  %h2 Implementation Progress
/  %h3 In-Progress
/  .block
/    %ul
/      %li Skeleton Tree-based parser
/      %li Bytecode Design
/  %h3 TODO
/  .block
/    %ul
/      %li Bytecode Compiler
/      %li Bytecode Interpreter

%section
  %h2 Questions?

%section
  %h2 Thank You!
