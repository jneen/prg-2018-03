%section#intro
  %h1 Magritte
  -# %p A UNIX Shell Suitable For Large Programs / A pipe-oriented language
  %p A Shell-like Model for General Purpose Programming
  .tagline
    %p
      .bigger Jeanine Adkisson,
      Johannes Westlund, Hidehiko Masuhara
    %p Programming Research Group, Tokyo Institute of Technology
    %p
      %code
        slides:
        %a(href="https://jneen.github.io/prg-qush-slides") https://jneen.github.io/prg-qush-slides

    %p
      %code
        code:
        %a(href="https://github.com/prg-titech/magritte") https://github.com/prg-titech/magritte

    %p
      %code
        mailto:
        %a(href="mailto:jneen@jneen.net") jneen@jneen.net
        ,
        %a(href="mailto:masuhara@acm.org") masuhara@acm.org


%section<
  %h2 Problem: Shells Are Bad.
  %h2 But Everyone Uses Them.
  .vs>
    = code 'shell' do
      :plain
        #!/bin/bash

        # complicated defaults
        getc() {
          IFS= read -r -n1 -d '' "$@"
        }
  .vs>
    = code 'shell' do
      :plain
        #!/bin/bash

        # whitespace separation issues
        greeting='hello world'
        count-argv $greeting # => 2
        count-argv 'hello world' # => 1


%section
  %h2 Why Does Everyone Use Shells?
  .vs3>
    .box.fragment.fragment-dim
      %h3 Ubiquity:
      .block
        Available on any UNIX platform!
  .vs3>
    .box
      %h3 OS Fluency:
      .block
        &ldquo;Feels&rdquo; directly connected to the OS

  .vs3>
    .box
      %h3 REPL Feel
      .block
        Designed for heavy REPL use

%section
  %h2 New Language: Magritte

  %h3 Goals:
  .vs3>
    .box
      %h3 OS Fluency:
      .block
        &ldquo;Feels&rdquo; directly connected to the OS

  .vs3>
    .box
      %h3 REPL Feel
      .block
        Designed for heavy REPL use

  .vs3>
    .box.box-special
      %h3 General Use
      .block
        A usable general-purpose language

  %p Should be able to write large programs!

// %section
//   %h2 Design Philosophy
// 
//   %h3 Strategies:
//   %ul
//     %li
//       Derive all language concepts from UNIX APIs<br>
//       (as opposed to embedding another language's semantics,<br>
//       like <code>xonsh</code> or <code>scheme-shell</code>)
//     %li Minimal marshalling, no quotes for <code>exec</code> or string literals
//     %li Left-to-right pipe-based composition
//     %li
//       Provide real value-based semantics and abstraction tools<br>
//       (as opposed to everything-is-a-string, like <code>es</code> or <code>fish</code>)

%section(data-transition="slide-in fade-out")
  %h2
    What Makes a Shell Feel <span class="dune">&ldquo;Fluent&rdquo;</span>?
  .bigger
    %strong.sandy Core language concepts directly map to OS APIs
  .block
    .vs3>
      .box environments
    .vs3>
      .box argv
    .vs3>
      .box processes
    .vs3>
      .box pipes, files, stdio
    .vs3>
      .box commands
    .vs3>
      .box return codes

  %p
    %span.dune Common language of programs:
    every <span class="dune">&ldquo;general-purpose&rdquo;</span> programming language understands these.


%section(data-transition="fade-in slide-out")
  %h2 Main Idea
  %h3 A language that expands UNIX concepts to language abstractions

  .block
    .vs3>
      .box environments:<br>prototype objects!
    .vs3>
      .box argv:<br>vectors (nestable!)
    .vs3>
      .box processes:<br>threads!
    .vs3>
      .box pipes, files, stdio:<br>channels!
    .vs3>
      .box commands:<br>functions (w/closure!)
    .vs3>
      .box return codes:<br>error handling!

  .block
    %p
      This is in contrast to projects like <code>xonsh</code>
      or <code>scheme-shell</code>, which apply an existing
      language's semantics to a shell context.

-#%section
-#  %h2 Syntax Design:<br> Pipe-Based Composition
-#  %h3 Compose complex pipelines linearly
-#
-#  %h4 Why not use lisp-like syntax?
-#
-#  .block.replacement
-#    .fragment.current-visible
-#      = code 'cursorscheme' do
-#        :plain
-#          ; user types (▮ = cursor)
-#          (fan 4 fetch-webpage (file-lines "url-list.txt"))▮
-#
-#    .fragment.current-visible
-#      = code 'cursorscheme' do
-#        :plain
-#          ; user backtracks to the front
-#          ▮(fan 4 fetch-webpage (file-lines "url-list.txt"))
-#
-#    .fragment.current-visible
-#      = code 'cursorscheme' do
-#        :plain
-#          ; user types
-#          (sort (map downcase (map '(html-select ".title") ▮(fan 4 fetch-webpage
-#                          (file-lines "url-list.txt"))
-#
-#    .fragment.last
-#      = code 'cursorscheme' do
-#        :plain
-#          ; user scans to the end and completes parentheses
-#          (sort (map downcase (map '(html-select ".title") (fan 4 fetch-webpage
-#                          (file-lines "url-list.txt")))))▮
-#
-#  %h4.fragment Lisp-like syntax is not ideal for REPL composition

-#%section
-#  %h2 Syntax Design:<br> Pipe-Based Composition
-#  %h3 Compose complex pipelines linearly
-#
-#  .replacement
-#    .fragment.current-visible
-#      = code 'qsh' do
-#        :plain
-#          # user types
-#          file-lines url-list.txt | fan 4 %fetch-webpage▮
-#    .fragment
-#      = code 'qsh' do
-#        :plain
-#          # user continues typing
-#          file-lines url-list.txt | fan 4 %fetch-webpage | each [%html-select title]
-#            | each %downcase | sort▮
-#
-#  .space
-#  %h4.fragment Design Goal: Can always continue typing to use previous results

%section
  %h2 Language Design
  %h3 Allowing for large programs

%section
  %h2 High-level Example

  .block
    .replacement
      .fragment.current-visible
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
                | fan $threads %get-webpage
                | each (?page =>
                    put [($page!select title)
                         ($page!select description)])
                | each [%map %downcase]
            )

      .fragment.current-visible
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
            # file-lines $f
            #   | fan $threads %get-webpage
            #   | each (?page =>
            #       put [($page!select title)
            #            ($page!select description)])
            #   | each [%map %downcase]
            )

      .fragment.current-visible
        .bubble(style="top: 25%; right: 5%")
          %p
            each line is <strong>output</strong>
            as a separate string
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
            #   | fan $threads %get-webpage
            #   | each (?page =>
            #       put [($page!select title)
            #            ($page!select description)])
            #   | each [%map %downcase]
            )

      .fragment.current-visible
        .bubble(style="top: 30%; right: 15%")
          %p
            concurrent processing with a<br>
            function (passed by value)
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
                | fan $threads %get-webpage
            #   | each (?page =>
            #       put [($page!select title)
            #            ($page!select description)])
            #   | each [%map %downcase]
            )

      .fragment.current-visible
        .bubble(style="top: 43%; right: 15%")
          %p
            call a lambda function on every input
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
                | fan $threads %get-webpage
                | each (?page =>
            #       put [($page!select title)
            #            ($page!select description)])
            #   | each [%map %downcase]
            )

      .fragment.current-visible
        .bubble(style="bottom: 35%; right: 15%")
          %p
            parentheses <strong>collect</strong> the output

        .bubble(style="bottom: 5%; right: 15%")
          %p
            unquoted names are strings (&ldquo;barewords&rdquo;)
        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
                | fan $threads %get-webpage
                | each (?page =>
                    put [($page!select title)
                         ($page!select description)])
            #   | each [%map %downcase]
            )

      .fragment
        .bubble(style="bottom: 15%; right: 15%")
          %p
            a vector is <strong>callable</strong><br>
            as a curried function

        = code 'qsh' do
          :plain
            # given a filename that contains a list of urls,
            # return all the titles and descriptions.
            (get-titles-and-descriptions ?f) = (
              file-lines $f
                | fan $threads %get-webpage
                | each (?page =>
                    put [($page!select title)
                         ($page!select description)])
                | each [%map %downcase]
            )
  %p.fragment
    This kind of pipeline would be impossible in shell! ...but the
    composition strategy is exactly the same



-# %section
-#   %h2 Language Design: Values
-# 
-#   .vs>
-#     %h3 Problem:<br> Everything Is A String
-# 
-#     .box
-#       %ul
-#         %li Variables can hold strings, lists, or associative arrays, <strong>but</strong>
-#         %li Function arguments and pipes can only receive or output strings
-#         -#%li Data structures are impossible/inconvenient
-#         -#%li Anonymous functions are impossible/inconvenient
-#         %li Makes large programs an unreasonable goal
-# 
-#   .vs>
-#     %h3 Solution:<br> Introduce values!
-#     .box
-#       %ul
-#         %li
-#           <strong>values</strong> can be:
-#           string, number, vector, environment,
-#           channel, process, function, etc.
-#         %li
-#           Can be used in variables, function arguments, and
-#           <strong>can be passed through pipes</strong>
-#         -#%li
-#         -#  Channels can handle values, not just bytes
-#         -#%li
-#         -#  Functions take values as arguments, and output values
-# 
-#   .block
-#     %p
-#       This is in contrast with projects like <code>es</code> or
-#       <code>fish</code>, where pipes can only receive bytes.
-# 
-# %section
-#   %h2 Language Design: Call Semantics
-#   .block
-#     %h4 Problem: Shell functions don't have return values
-#     %h4 Solution: Multiple return values using stdout.
-# 
-#   .block(style="margin-top: -2em")
-#     .vs>
-#       %h3 Processes <code>put</code> values
-#       = code 'qsh' do
-#         :plain
-#           (count-three) = (
-#             put 1
-#             put 2
-#             put 3
-#           )
-# 
-#       .space
-#       %h4 How should we capture these outputs?
-#     .vs.fragment>
-#       %h3 Expansion
-#       = code 'console?lang=qsh' do
-#         :plain
-#           ; put 0 (count-three) 4
-# 
-#           -- expands to --
-#           ; put 0 1 2 3 4
-# 
-#           => 0; => 1; => 2; => 3; => 4
-# 
-#   .fragment(style="margin-top: -1.5em")
-#     Equivalent to shell <code>$(command arg arg)</code>, but without the whitespace issues
-# 
-# 
-# %section(data-transition="slide-in fade-out")
-#   %h2 Language Design: Variable Scope
-#   .block
-#     .space
-#     %h4 Problem: UNIX programs expect dynamic variables
-#     %h4 Solution: Support both lexical and dynamic variables
-# 
-#   .block
-#     .vs>
-#       %h3 Dynamic with <code>$</code>
-#       = code 'console?lang=qsh' do
-#         :plain
-#           ; x = 1
-#           ; (f) = (put $x)
-#           ; (g) = (x = 2; f)
-#           ; g
-#           2
-# 
-#     .vs>
-#       %h3 Lexical with <code>%</code>
-#       = code 'console?lang=qsh' do
-#         :plain
-#           ; x = 1
-#           ; (f) = (put %x)
-#           ; (g) = (x = 2; f)
-#           ; g
-#           1
-# 
-#   Dynamic variables = UNIX environment variables
-# 
-# %section(data-transition="fade-in slide-out")
-#   %h2 Language Design: Variable Scope
-#   .block
-#     .space
-#     %h4 Problem: UNIX programs expect dynamic variables
-#     %h4 Solution: Support both lexical and dynamic variables
-# 
-#   .block
-#     .vs>
-#       %h3 Dynamic with <code>$</code>
-#       = code 'console?lang=qsh' do
-#         :plain
-#           ; x = 1
-#           ; (f) = ($x = 3)
-#           ; (g) = (x = 2; f; put $x)
-#           ; g; put $x
-#           3 1
-# 
-#     .vs>
-#       %h3 Lexical with <code>%</code>
-#       = code 'console?lang=qsh' do
-#         :plain
-#           ; x = 1
-#           ; (f) = (%x = 3)
-#           ; (g) = (x = 2; f; put $x)
-#           ; g; put $x
-#           2 3
-# 
-#   Dynamic variables = UNIX environment variables

/%section
/  %h2 Language Design: Objects
/
/  .block
/    .vs>
/      %h3 Instantiation
/      = code 'qsh' do
/        :plain
/          my-env = {
/            # regular members
/            x = 1
/
/            # functions
/            (set-x ?value) = (
/              # $self set dynamically
/              # as in javascript
/              $self!x = %value
/            )
/          }
/
/    .vs>
/      %h3 Usage
/      = code 'qsh' do
/        :plain
/          # regular members
/          $my-env!x
/
/          # functions
/          $my-env!my-function 23
/
/          +$my-env (
/            my-function $x
/          )




/%section
/  %h2 Language Design: Compatibility
/
/  .vs>
/    %ul
/      %li Idea: pass lambdas to external programs
/      %li <code>/usr/bin/qush-external-<emph>N</emph></code>
/      %li Standard <code>exec</code> interface
/      %li <code>$__QUSH_SERVER</code> and <code>$__QUSH_FUNCTION_<emph>N</emph></code>
/
/  .vs>
/    = code 'qsh' do
/      :plain
/
/        # calls into $my-fn in the
/        # current runtime once
/        # every 3 seconds
/
/        ; /usr/bin/watch -d 3 $my-fn
/
/  Bash cannot currently do this.


/%section
/  %h2 Language Design: Error Handling
/  %h3 Default Behavior
/
/  An &ldquo;error&rdquo; includes:
/
/  .block
/    %ul
/      %li Assertion error (type error or explicit crash)
/      %li External crash signal (SIGINT, etc)
/      %li A child process exits with nonzero code
/      %li A blocked channel closes


/%section
/  %h2 Language Design: Error Handling
/  %h3 Default Behavior
/  When an error happens:
/  .block
/    %ul
/      %li All child processes are sent SIGINT (or echo signal)
/      %li Compensations are run in reverse order (more later)
/      %li All channels are closed
/      %li Exit with an error code (default 1)

/ %section
/   %h2 Language Design: Error Handling
/   %h3 Plain Recovery (Continuing)
/ 
/   .block
/     = code 'qsh' do
/       :plain
/         command || command-if-error
/         command && command-if-no-error
/         command && command-if-no-error !! command-if-error
/ 
/   .block Internal errors (non-zero exits) in the original command are &ldquo;rescued&rdquo; (ignored)
/ 
/   .block <code class="scarletred2">TODO:</code> Syntax for targetting error types
/ 
/ 
/ %section
/   %h2 Language Design: Error Handling
/   %h3 Compensation
/ 
/   = code 'qsh' do
/     :plain
/       touch /tmp/lock %% rm -f /tmp/lock # compensate an error
/ 
/       %x = command %% reset # sets $COMP_REF and $COMP_PREV
/ 
/       checkpoint # clears the current compensation stack
/ 
/   .space
/   = code 'qsh' do
/     :plain
/       touch /tmp/lock %%! rm -f /tmp/lock # run on error or at checkpoint
/   %br
/ 
/   .block <code class="scarletred2">TODO:</code> Compensation boundaries
/   /Options being considered for compensation boundaries:
/   /.block
/   /  %ul
/   /    %li Only at the procedure level
/   /    %li Controlled by a special environment variable



/%section
/  %h2 Language Design: Concurrency
/  Many things TBD, but the principle is:
/  %h3 Behave as closely to UNIX processes as possible.
/  .vs>
/    = code 'qsh' do
/      :plain
/        # spawn
/        & command $arg $arg > $out < $in
/
/        # send
/        put message > $in
/
/        # receive
/        get message < $out
/    // vim syntax highlighting gets confused here
/    // >
/  .vs>
/    .block
/      %ul
/        %li local environment contains file handles 0~127
/        %li 0 = stdin, 1 = stdout, 2 = stderr, etc
/    = code 'qsh' do
/      :plain
/        command | command
/        command |[5>2] command
/        command |[2>$ERROR_LOG] command

-# %section
-#   %h2 Concurrency Model
-# 
-#   .vs
-#     %ul
-#       %li.fragment
-#         Users can freely spawn
-#         %strong.dune processes
-#       %li.fragment
-#         Processes communicate and coordinate through
-#         %strong.dune synchronous channels
-#       %li.fragment
-#         -#%strong.go-get-it [new]
-#         Processes
-#         %strong.dune register
-#         their open input/output channels at startup, and
-#         %strong.dune deregister
-#         them at exit.
-#       %li.fragment
-#         -#%strong.go-get-it [new]
-#         A channel
-#         %strong.dune closes
-#         when either its last registered reader or registered writer exits.
-#         At closing, we
-#         %strong.dune interrupt
-#         all blocked processes, as well as any process that attempts to
-#         reopen the channel.
-# 
-#   %h4.fragment (Will explain all this in later slides!)




%section
  %h2 Concurrency: Intrinsic Operations

  .vs>
    %h4 Channels as values
    = code 'qsh' do
      :plain
        channel = (make-channel)

        # write values with `put`
        put 1 2 3 > $channel

        # read a value with `get`
        get < $channel
    -#>

    .space

    %h4 Spawning: Run in the background
    = code 'qsh' do
      :plain
        & some-function arg arg
        & some-function >$out <$in
        & foo | bar | baz
    -#>


  .vs>
    %h4 Anonymous channels (pipes)
    = code 'qsh' do
      :plain
        command-1 | command-2

        # equivalent to

        channel = (make-channel)

        & command-1 > $channel
        command-2 < $channel

-# vimmmm
-# >

-#%section
-#  %h2 Concurrency: Concepts
-#
-#  %p
-#    Channels are <strong>synchronous</strong>:
-#  %ul
-#    %li reader and writer must both be present to make a communication.
-#    %li Writes will <strong>block</strong> until the channel is read.
-#
-#  .vs>
-#    %h4 Block on read
-#    = code 'qsh' do
-#      :plain
-#        (sleep 10; put 1) | (get; put 2)
-#
-#
-#  .vs>
-#    %h4 Block on write
-#    = code 'qsh' do
-#      :plain
-#        put 1 | (sleep 10; get)
-#
-#  %h4.fragment This is different than bash!

%section
  %h2 Concurrency: Interruption

  %h3 What should the behavior of this code be?

  .vs>
    = code 'qsh' do
      :plain
        (count-forever ?n) = (
          put $n
          count-forever (incr $n)
        )

        (take 0) = ()
        (take ?n) = (
          put (get)
          take (decr $n)
        )

        count-forever 0 | take 10

  .replacement.vs>
    .fragment.current-visible
      = code 'qsh' do
        :plain
          => 0; => 1; => 2; => ...; => 9

          # but what happens to the process
          # running `count-forever`...?

    .block.fragment
      %h4 Naive Approach: Nothing!

      %ul
        %li
          %span.code count-forever
          tries to write 10 to the output, blocks
        %li
          %span.code take
          returns after 9, never reads
        %li
          %span.code count-forever
          gets garbage-collected later

    .fragment.box
      %h4 This works!
      %p ...as long as there are no cleanup actions

%section(data-transition="slide-in fade-out")
  %h2 Concurrency: Interruption

  %h3 But what if there are cleanup actions?

  .vs>
    = code 'qsh' do
      :plain
        (file-lines ?fname) = (
          file = (open-file $fname
            %%! close-file $fname)
          ...
        )


        file-lines /tmp/huge-file
          | take 10

  .vs.nfragment>
    %h4
      With the naive approach, the file will remain open until gc!

    .space
    %p.left Processes expect to be cleaned up when the processes they're communicating with hang up.

    .space
    %p.left They expect an <strong>interrupt</strong> signal of some kind.

  %p.cite <em>Inoue, Aotani, and Igarashi [2018]: &ldquo;ContextWorkFlow: A Monadic DSL for Compensable and Interruptible Executions&rdquo;</em>

%section(data-transition="fade-in slide-out")
  %h2 Concurrency: Interruption

  %h3 Idea: channel-closing semantics

  .vs>
    = code 'qsh' do
      :plain
        (file-lines ?fname) = (
          file = (open-file $fname
            %%! close-file $fname)
          ...
        )


        file-lines /tmp/huge-file
          | take 10

  .vs>
    %ul
      %li.fragment
        When
        %span.code take 10
        returns, it
        %strong closes
        the channel.

      %li.fragment
        The
        %span.code file-lines
        process is either blocked on the channel or tries to write later

      %li.fragment
        Either situation results in the
        %span.code file-lines
        process being
        %strong< interrupted
        , and having its cleanup actions run.

      -#.space
      -#%h4.fragment This is how it works in bash already!

%section
  %h2 Concurrency: Interruption

  %h3 Multiple Readers/Writers

  .block
    <strong>BUT: </strong>
    Since spawned processes inherit inputs and outputs,<br>
    it will be common to have <strong>multiple readers and writers</strong><br>
    interacting with a channel at the same time.

  .block.fragment
    %p
      %strong If we close channels when a process exits, how should this code behave?

    = code 'qsh' do
      :plain
        (drain) = (put (get); drain)

        put one two three four five | (& take 2; & take 10) | take 5

  -#=> 0 1 3 2 4

  .space
  %h4.fragment We must leave channels open if they're still in use

%section
  %h2 Concurrency: Interruption

  %h3 Idea: Interrupt a process when it's probably blocked forever

  %h4.pink-merengue &ldquo;The last one to leave has to turn off the lights&rdquo;

  .space

  %center
    close a channel when:<br>
    %strong.bigger
      The last reader exits
    %br/

    \~ or ~
    %br/

    %strong.bigger
      The last writer exits

-#%section
-#  %h2 Concurrency: Interruption
-#
-#  %h3 Idea: Interrupt a process when it's probably blocked forever
-#
-#  %center
-#    interrupt a process when:<br>
-#    %strong.bigger.fragment
-#      a channel it is blocked on closes
-#    %br/
-#
-#    .fragment
-#      \~ or ~
-#      %br/
-#
-#      %strong.bigger
-#        it tries to interact with a closed channel
-#      -#.fragment (why?)

-#%section
-#  %h2 Concurrency: Interruption
-#
-#  %h3 Problem: Reopening
-#
-#  .vs>
-#    %h4 What should this code do?
-#
-#    = code 'qsh' do
-#      :plain
-#        c = (make-channel)
-#        & count-forever > $c
-#        & take 10 < $c
-#        put 10 > $c
-#    .space
-#
-#    %p.fragment
-#      This code contains a <strong>race condition</strong>.
-#
-#    -#>
-#  .vs>
-#    %div
-#      %p.left.fragment
-#        If <code>take 10</code> returns before <code>put 10</code> is executed,
-#        the channel will <strong>close</strong>. Otherwise the number 10 will be
-#        inserted into the first 10 elements.
-#      .space
-#      %p.left.fragment
-#        If we allow <code>$c</code> to be <strong>reopened</strong>, then
-#        there is a worse race condition: if the channel closes before the final
-#        <code>put</code>, we will remain blocked forever on the channel.
-#
-#  %h4.fragment
-#    Therefore: Channel closing is permanent - further interactions will interrupt


/%section
/  %h2 Concurrency: Interruption
/
/  %h3 Problem: Closing Semantics = No Dynamic Channels
/
/  %h4 We can no longer write to a channel and leave it open!
/
/  .block
/    = code 'qsh' do
/      :plain
/        (make-broadcaster) = (
/          outputs = []
/
/          put {
/            (subscribe ?ch) = (%outputs = [...%outputs %ch])
/            (publish ?msg) = (for %outputs | each (%ch => put %msg > %ch))
/          }
/        )
/
/  %h4.fragment We can't keep a dynamic list of channels open continuously for writing.

/ %section
/   %h2 Concurrency: Interruption
/ 
/   %h3 Possible Solutions
/ 
/   .block
/     .vs>
/       %h4 Multiple writers to stdout (<span class="code">&amp;1</span>)
/       = code 'qsh' do
/         :plain
/           (subscribe >?c) = (
/             %channels = [...%channels %c]
/ 
/             # never return!
/             # keep stdout open!
/             sleep-forever
/           )
/ 
/           # usage
/           $bc!subscribe > $somewhere
/ 
/     .vs.fragment>
/       %h4 This is how UNIX FIFOs work!
/       %h4 (except they have a fixed buffer)
/       = code 'console' do
/         :plain
/           ~$ echo 'demo time!'
/           demo time!
/           ~$ 



%section
  %h2 Validation

  %h4 Need to validate:
  %ul
    %li.fragment Magritte is appropriate <strong class="dune">for writing large programs</strong>
    %li.fragment Magritte is appropriate <strong class="dune">for shell scripting</strong>
    %li.fragment Magritte is appropriate <strong class="dune">as an interactive system shell</strong>



%section
  %h2 Implementation Progress

%section
  %h2 Implementation Progress
  %p
    %code
      code:
      %a(href="https://github.com/prg-titech/magritte" style="text-decoration: none") https://github.com/prg-titech/magritte

  .block
    %ul
      %li
        %strong.sandy [done]
        Ruby Interpreter (&ldquo;magritte&rdquo;)
      %li
        %strong.sandy [done]
        Feature complete!
      -# %li
      -#   %strong.pink-merengue [future-work]
      -#   write some example programs, develop programming patterns and styles (Johannes)
      %li
        %strong.pink-merengue [future-work: HARD]
        write the UNIX integration layer
      %li
        %strong.pink-merengue [future-work (later)]
        design a VM, bootstrap with RPython
      %li.fragment
        %strong.go-get-it DEMO


/ %section
/   %h2 Magritte
/ 
/   %h4 Example 1
/ 
/   = code 'ruby' do
/     :plain
/       # (put 1; put 2) | add (get) (get) | mul 2 (get)
/       code do
/         s { put 1; put 2 }.p { put(get + get) }.p { put(get * 2) }.call
/ 
/         put 10
/       end
/ 
/       assert { output == [6, 10] }
/ 
/ %section
/   %h2 Magritte
/ 
/   %h4 Example 2
/ 
/   = code 'ruby' do
/     :plain
/       code do
/         s { for_ (0...30) }.p {
/           s { drain }.go
/           s { drain }.go
/           s { drain }.go
/         }.p { take 30 }.call
/       end
/ 
/       assert { output.sort == (0...30).to_a }
/ 
/ %section
/   %h2 Magritte
/ 
/   %h4 Example 3
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def put(val)
/           Proc.current.stdout.write(val)
/         end
/ 
/         def get
/           Proc.current.stdin.read
/         end
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def map(&f)
/           loop do
/             put (f.call(get))
/           end
/         end
/ 
/         def take(n)
/           n.times { put(get) }
/         end
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   = code 'ruby' do
/     :plain
/       class Channel
/         def initialize
/           @mutex = Mutex.new  # mutex for changing channel state
/ 
/           @block_type = :none # block type
/           @block_set = []     # blocked threads/values/refs
/ 
/           @readers = Set.new  # registered readers
/           @writers = Set.new  # registered writers
/ 
/           @open = true        # open/close state
/         end
/ 
/         # ...
/       end
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h3 Channel States (<code>@block_type</code>)
/ 
/   .vs3>
/     %h4 <code>:write</code>
/     = code 'plaintext' do
/       :plain
/         (t,v)
/         ******** -> _(.w._)
/ 
/   .vs3>
/     %h4 <code>:none</code>
/     = code 'plaintext' do
/       :plain
/                 ~~~
/               v(.w.)v
/ 
/   .vs3>
/     %h4 <code>:read</code>
/     = code 'plaintext' do
/       :plain
/                      (t,_)
/         (_.w.)_ <- *******
/ 
/   -#>
/ 
/   .vs3>
/     block set contains<br>
/     %code (thread, value)
/     pairs (<code>Sender</code>)
/ 
/   .vs3>
/ 
/   .vs3>
/     block set contains<br>
/     %code (thread, ref)
/     pairs (<code>Receiver</code>)
/ 
/ 
/ 
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h4 Blocked Writers
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def read
/         # ...
/         case @block_type
/         when :none, :read
/           # ...
/         when :write
/           sender = @block_set.shift
/           @block_set.empty? &&
/             @block_type = :none
/ 
/           sender.wakeup
/           return sender.val
/         end
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def write(val)
/         # ...
/         case @block_type
/         when :none, :write
/           @block_type = :write
/           @block_set <<
/             Sender.new(Thread.current,
/                        val)
/           @mutex.sleep
/         when :read
/           # ...
/         end
/ 
/   -# >
/ 
/ %section
/   %h2 Magritte: Channels
/ 
/   %h4 Blocked Readers
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def read
/         # ...
/         case @block_type
/         when :none, :read
/           @block_type = :read
/           receiver =
/             Receiver.new(Thread.current)
/           @block_set << receiver
/ 
/           @mutex.sleep
/           return receiver.val
/         when :write
/           # ...
/         end
/   -# >
/ 
/   .vs>
/     = code 'ruby' do
/       :plain
/         def write(val)
/         # ...
/         case @block_type
/         when :none, :write
/           # ...
/         when :read
/           receiver = @block_set.shift
/           @block_set.empty? &&
/             @block_type = :none
/ 
/           receiver.val = val
/           receiver.wakeup
/           # ...
/         end
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   .block
/     %ul
/       %li Register and unregister processes at launch and exit
/       %li
/         When the last process unregisters from either end,
/         %ol
/           %li Set the channel state to closed
/           %li Interrupt all the processes in the block set
/           %li Cause any further reads/writes to interrupt the process
/ 
/       %li
/         Important: Eagerly remove our own thread from the block set
/         so we don't interrupt ourself during shutdown!
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   = code 'ruby' do
/     :plain
/       class Proc
/         # ...
/         def start
/           # ...
/           @env.each_input { |c| c.add_reader(self) }
/           @env.each_output { |c| c.add_writer(self) }
/           @thread[:magritte_start_mutex].unlock # start running user code!
/           # ...
/         end
/ 
/         # ...
/ 
/         def cleanup!
/           @env.each_input { |c| c.remove_reader(self) }
/           @env.each_output { |c| c.remove_writer(self) }
/         end
/ 
/ %section
/   %h2 Magritte: Channel Registration
/ 
/   = code 'ruby' do
/     :plain
/       def remove_reader(process)
/         action = @mutex.synchronize do
/           next :nop unless @open
/           @block_set.reject! { |b| b.thread == process } if @block_type == :read
/ 
/           @readers.delete(process)
/           next :nop if @readers.size > 0
/ 
/           @open = false
/           :close
/         end
/ 
/         @block_set.each(&:interrupt!) if action == :close
/       end
/  -# >
/%section
/  %h2 Implementation Progress
/  %h3 RPython + MacroPy
/  .block
/    = code 'python' do
/      :plain
/        @functor
/        class Syntax:
/            class list([elements]): pass
/            class paren([statements]): pass
/            class assign(~lhs, ~rhs): pass
/            class bare(value/unicode): pass
/            class dynvar(name/unicode): pass
/            class pipe(~lhs, ~rhs): pass
/            class call(loc/LocRange, ~func, [args]): pass
/            ...
/
/%section
/  %h2 Implementation Progress
/  %h3 In-Progress
/  .block
/    %ul
/      %li Skeleton Tree-based parser
/      %li Bytecode Design
/  %h3 TODO
/  .block
/    %ul
/      %li Bytecode Compiler
/      %li Bytecode Interpreter

%section
  %h2 Questions?

%section
  %h2 Thank You!
